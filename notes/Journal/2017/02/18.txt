Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-02-18T09:53:59+00:00

====== Saturday 18 Feb 2017 ======

An interesting thought has arisen.

Currently ProtoEvent records are linked to Event records.  If the ProtoEvent goes away, so do the corresponding events.  This corresponds to deleting a line in the ExamCycle screen.  You don't need to do a generate or anything like that - it would happen immediately.

Do I want a similar relationship to exist for ProtoCommitment and ProtoRequest records?  If I do, then events would change immediately when the ProtoEvent lost one of these records, which is not how it is currently intended to work.  OTOH, the user has no way of deleting either of these without deleting the whole event.  You can change the room, but that doesn't delete the ProtoCommitment record - it merely updates it with a new location.  You'd still need to run a generate to make it take effect.

I'm inclined //not// to put in a hard link between ProtoCommitment/ProtoRequest records and the corresponding Commitment/Request ones.  I think it could lead to some surprising behaviour.  If you delete the ProtoEvent then everything (including Commitment and Request records) will go.  I will however use the source_id field in the commitment to keep track of which are mine.

What is the source_id in Commitment records currently used for?  Almost all nil.  We use it for covers when importing them from iSAMS.

Is there any chance of an overlap here?  I don't think so - I'm not using covers for setting up invigilation.  Cover implies someone is doing something on behalf of someone else who would otherwise be doing it.

Ah - there is a slight danger.  In my current code, if I simply go looking for a commitment on the event with the right ID then it's just possible that I might find a cover commitment which coincidentally has the same ID.  I need something to link the ProtoCommitment to the actual Commitment.

I could put in a d/b link, but make the link do a nullify instead of a destroy when it goes away.

Ah - need to check explicitly for events which exist outside our stated range.  They all need to go away.  Done that.

It occurs to me that it would also be useful to be able to split a ProtoEvent and all its events.  If a room became unavailable for part of an exam cycle, one might want to move some days to a different room.  As it stands, if the whole cycle for that room has been entered as a single ProtoEvent you can only move the lot to a different room.

It would need a ProtoEvent#split(date) method which took, say, the start date of the second half of the split.  It would check that the date was strictly between its own existing dates, then create a new ProtoEvent with that as a start date and its own end date as the end date.  It would clone all its ProtoCommitment and ProtoRequest records.  It would adjust its own end date to be the day before the indicated date, and then move all existing events after the date to be attached to the new ProtoEvent record instead of the old one.  Perhaps a ProtoEvent#take(event) method which handed it over, adjusting all the commitments and requests in the process.  Whilst the conversion is in progress, it would be important to keep track of matching ProtoCommitment and ProtoRequest records to facilitate handing things over.

If someone edits the time of an invigilation slot and then re-generates, should we change it back again or assume he knows what he's doing?
