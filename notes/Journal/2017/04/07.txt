Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2017-04-07T08:43:20+01:00

====== Friday 07 Apr 2017 ======

Looking at adding the ability to specify a different default number of staff for different room records (proto_events) within a cycle.  The actual storage is not a problem because it's held in the proto_request attached to the proto_event, but providing the means to edit it whilst conforming to the MVC model is more tricky.

Arguably the work should be done in the controller, but when we want it to appear to be an attribute of the proto_event, and so it needs at least a method in the proto_event model so that the standard index code can hoik it out when the row is being displayed.

Currently I have some invigilation-specific code in the proto_event model and some in the controller.  Arguably, neither should contain any.  A thought occurs - why not wrap the proto_event model in a kind of pseudo-model (a bit like I have done for tutor/teaching groups, but without the extra d/b record) and then have a controller which handles that.  I can use the existing proto_event controller for now, but will probably want to move it when the proto_event comes to be used for other kinds of rotas.

What looked like a simple little addition now looks like quite a lot of work, but would have the advantage of cleaning up my code a bit ready for future enhancements.  Should I use the FakeActiveRecord model?  Perhaps.

Right - first (possibly only?) objective for today.  Split the existing proto_event model in two.  Only stuff which is genuinely general for the proto_event should be in the main model.  Anything specific to invigilation should be in a FakeActiveRecord called invigilation_proto_event.  The controller will then manipulate the latter one.  In the fullness of time the controller should probably be renamed.  The controller will get thinner, and the work will be done in the invigilation_proto_event model.

Hang on a minute - first problem.  I find my proto_events because they are linked to an exam cycle.  Only a real active record model can be linked in this way.  The controller will therefore need to find the proto_events and construct the corresponding invigilation_proto_event records.  The controller therefore needs knowledge of the subterfuge, and if I want to use the existing:

''@exam_cycle.proto_events''

call then I'll probably want to add some preload to it.

Interesting point.  When you create a new InvigilationProtoEvent record, it really needs to know whether it is genuinely new (in which case it will need to create several records when you choose to save it), or reflecting an existing d/b ProtoEvent record (in which case it wants to do some database loading).  For this reason, I'm wondering whether perhaps I should stop using FakeActiveRecord for it to inherit from.  I need more control.

Thinking back to Tutor/Teaching groups, when you create one of those you actually get the Group record back.  The group record knows it might have a persona, and delegates messages which it doesn't understand to the persona.

Could one do that with the ProtoEvents?  Add some delegation code, and the means to have a ProtoEvent call its persona?  It would have a Persona only for as long as it was in memory.

Can I see ProtoEvents having more than one persona type?  Yes, I think I can.  The whole idea of ProtoEvents was to use them to create a collection of real events according to some kind or rota_template.  As such, they would be used for things like peripatetic music lesson schedules, staff duty slots, etc.  They were never intended to be solely for exam invigilation.  It would therefore seem to make sense to allow ProtoEvents to record what type of ProtoEvent they are.  This //would// need to be recorded in the database, so that when the ProtoEvent is reloaded it knows what kind of persona record needs to be created.  And then of course, persona_types might need their own database records, although I don't think the invigilation one does.  Groups sometimes have a real database record and sometimes not.

So - two possible general approaches:

* Have an InvigilationProtoEvent record which wraps a ProtoEvent record and passes calls through to it.
* Have a persona attached to a ProtoEvent, and delegate unknown calls to it.

I started with the problem of wanting to call methods on the ProtoEvent which didn't really belong there.  Specifically I wanted to call "num_staff" or something like that.  The second method starts to sound more attractive.

When you create or load a ProtoEvent, you give it its own instance of an InvigilationPePersona.  It can then delegate unknown calls to that item, which itself has knowledge of its ProtoEvent.  I start to like this.

Is there a danger that if two Ruby objects have links to each other then you have a deadly embrace and they stay in memory forever?

Does the ProtoEvent record actually need an extra record?  Could it not do a conditional mix-in of some extra methods?  I think you can do this in Ruby, and in fact I may have done it before.  obj.extend().  Where have I done this before?  I seem to recall it, but not sure where.  Dynamic programming and mixing in modules.  Where?  In my importer code.  There I include a module which when included sends a message to the parent telling it to extend itself with some more code.  Not quite what I want here, but it can be done.

This sounds interesting.  I can see how it works on loading an existing record.

* Load ProtoEvent record
* Check type and mixin relevant module
* Call some kind of loaded method which finds ancillary information (like room and num_staff)

How does it work for creating a record?  They type becomes an additional parameter.  If specified it causes a mixin, which in turn adds new methods.  Need to be very sure that the mixin occurs only once.

Had quite a long think.  The interesting part is the early bit of the object's life cycle.  We have to cope with create! being called with a hash of parameters, which may then be assigned in any order.  Before we know what type it is we need to cope with any which don't seem to make sense, and then once we've found out the type we need to deal with them retrospectively, raising errors if any of them still doesn't make sense.

I think I probably need to hook in to after_initialize in the object life cycle.  By the time that function is called we should know what kind of ProtoEvent it is intended to be.  All passed parameters should now have been handled.
