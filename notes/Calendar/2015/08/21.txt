Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2015-08-21T09:46:43+01:00

====== Friday 21 Aug 2015 ======

Copied from the tail end of yesterday:

[*] Test code again with latest data
[*] Promote to live system
[*] Edit in start-of-term events
[*] Run import again
[*] Merge two locations - try on test system first.
[ ] Implement an alternative events_on in element.rb and test the two for speed in the real app

Testing the latest data from the live system.  Had to run the thing twice because I forgot to flag some of my test events as being suspensions.

Finished entering up the Tuesday.  Let's try running the script again.  Seems tolerably successful - at least for the Tuesday.  On to entering Wednesday.

Slightly curious that it's added some more timetable events.  Why?  Surely they should have been added last night?  I perhaps need to test that back on my test system by running in verbose mode.  Doesn't really tell me anything.  Run it again on the live system now I've entered the Wednesday stuff.  Seems fine, and didn't add any more lessons.  Not sure why it happened the first time - keep an eye on it.

What do I need to do to merge two locations.  I have LSSH and LSStudy, both coming from SB, both with events.  Each currently exists as both a location and a location alias.  I want to keep LSSH, plus give it a new friendly alias of "Lower School Study Hall"  Both locations currently have event commitments.  I need to lose one Location, but keep its location alias and point it at the other place.  Can I do that through the GUI?

Ah - we also have LSHW.  What's that?  It too is a location.  Does it have any events?  Yes, it does.  What?  Can't find anything recent.  It seems to have been used as a tutor location back in 2013/14.  Ah, could any of these be "Lower Sixth Study"?

So, SB has:

LSHW / LS Homework Room (it actually has an alias internally)
LSSH
LSStudy

Are these all the same place?  I'll need to make some enquiries.  LS might just stand for Lower Sixth as well.

I think that all I need to do once I've established the facts is point all the aliases to one actual location, perhaps create a new correct alias.  Choose just one of the short ones to be displayed, deprecate the others.  Move any commitments attached to the redundant existing locations to the one chosen one, then delete all the unwanted locations.  Instead of:

Alias  - Location  - Events
Alias  - Location  - Events
Alias  - Location  - Events

we end up with:

Alias  \
Alias  - Location - Events
Alias  /

All being well.  I could do with a helper method in the Location model to give all a location's commitments to another nominated location.

Done that - Location.absorb.  Seems to work, but do a little testing, particularly with no of events, and having both versions of a location committed to the same event.  Also, what happens to extant concerns if the item goes away - the concern should too.

Create an event involving both LSSH and LSStudy.

Just noticed that if I create a new Locationalias with the display bit set the name of the element changes, but if I delete it or amend it it doesn't.  Why one and not the other?  When we create a new location alias it tells the location to update its alias.  We don't do anything otherwise.  Now - what are our counts?

LSSH   189 commitments
LSHW 132 commitments
LSStudy 249 commitments

Combine them.  Now LLSH has 569 commitments.  Spot on - given that one of them was shared before.  How does our display look?  Beautiful.  All as expected.  Let's put this live.  Dump the database first, just in case.

All seemed to work OK - good.

Just written a new version of events_on, built on top of commitments_on.  Try to find a query which is reasonably expensive, then test with old an new versions of the code to check times.  I think I need a pupil, in order to get some nested commitments.

Angus Alder's first week of term takes 227ms, of which ActiveRecord is 45.7ms

Switch to the new one and try again.  It is now phenomenally slow - I wonder why?  I think it's running in a loop.  Now, it did eventually complete, but it took 13685 ms, of which 745.3ms were in ActiveRecord.  Interesting.  It does at least seem to have managed to come up with the requested data, but why so slow?  It does at the end get it down to one fast database hit, but there's a ludicrous number of hits leading up to it.  Why?  35696 lines of output for that one little query.

Most of the time is spent working out what groups the pupil is a member of.  Once we have that info, the remaining query is quite quick.  Now why the delay?  It really does do a lot of database hits to find out which groups the pupil is a member of on the indicated date.  The final count is 44.  I think part of the problem is that Angus Alder has been a member of a lot of groups in the past, and I'm testing all of them as I process.  He has 73 membership records, of which only 19 are current from today.  However, because of the "as_at" functionality, I need to check all of them before coming back.

Try it with a first year and see if it's any faster.  He takes 9105ms, of which activerecord is 608.8ms. Almost as bad.  It must be possible to improve the efficiency of this call.

The one by commitments *should* be faster.  I wonder whether I can make it so it actually is - an interesting task.

I think I may need to lose the "as_at" functionality in memberships.  I've never actually used it, and I think it may be too expensive.  I'd quite like to keep the exclusions, but where they exist they will inevitably add quite a bit of work to the searches - need to be used sparingly.

One thing I've discovered is that commitments_on isn't nearly as efficient as I thought it was.  The problem is in the way I build up the list of groups - it's horrendously inefficient and keeps going all the way back down the tree from each of the groups which I find.  It should be possible to do it much better.  Is it possible to do it better whilst retaining the as_at functionality?  And exclusions?

I think I've spotted a small efficiency improvement already.  Test with friend Angus Alder.  As things currently stand he takes 13638ms (Active Record 603.1ms).   One change.  12653ms (509.9ms).  Preload got it down to 10082ms (639.3ms)

Hah!  If I preload [:element, :element => :entity] I get it down to 3954ms (238.7ms)

Let's capture a log file to see what the sequence of searches is.

This time I managed 3797ms (165.2ms)

Even if I don't put the rest of this live, it might be a worthwhile saving for the existing ical downloads.  4s is too slow for interactive, but a lot better than 13s for a file download.  Must test that too.

Angus Alder is 10036.  Why am I looking at my own concern before looking at the one I was asked for?  One more preload and try again.  3724ms (162.7ms)  I think the log file got a lot bigger though.  No it didn't - I just did two steps.

The actual commitment loading is phenomenally efficient.  It's the group loading which is slow.  That's where I need to work, but it's quite hard to get your head around.

It's the recursive membership checking which is the problem.  I am not recursing properly, but instead using a sledgehammer approach.  I should keep enough information as I work up the tree to know whether or not the original element is actually a member.  Exclusions can be treated as a special case.  I fear that as_at really has to go.

Tried adding a couple of active_on filters to my memberships.  2228ms (134.9ms).  Getting slowly better.  Still not good though.  What does it do to an ical download for this pupil? element_id=10036.

With all my changes:  4219ms (247.2ms)

Without my changes 15839ms (634.8ms)

Yes, that's a worthwhile improvement.  Files are identical.
