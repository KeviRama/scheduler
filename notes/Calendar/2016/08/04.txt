Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2016-08-04T07:26:23+01:00

====== Thursday 04 Aug 2016 ======

Things for today:

[*] Discard OH event occurrences in the past
[ ] Create OH groups from records
[ ] Populate groups

After that I need to think about filling out the fine detail of how to do a roll-over.  I need to make sure old groups get their memberships properly terminated, and that pupils' extended names are updated.  It's time the live system started showing next year's data.

Why do my existing groups (and indeed, general records) pass some fields by means of the FIELDS_TO_CREATE attribute, and then others hard coded.  It makes sense for there to be some defaults, to which specific things can add, but the current way is a mess.  We should have:

* Some fields required by MIS_Record
* Some more for MIS_Group
* Some more specific to a type of group

The actual //data// may then have to be provided by the specific implementation, but the list of what's needed should be as general as possible.

Need to make a list of what I currently use, and then tidy up.

The save_to_db function is responsible for creating any database record - entity or group.  It uses FIELDS_TO_CREATE plus any extras passed at invocation.

Within MIS_Group, that function is then invoked with three extra fields, the values of which are hard-coded:

* starts_on: loader.start_date
* ends_on: self.era.ends_on
* era: self.era

Arguably these should not be hard-coded here, but should be in a default FIELDS_TO_CREATE constant, to which sub-classes then add what they want.

What fields do my current groups specify for creation?

Custom group
'''
DB_CLASS = Taggroup
DB_KEY_FIELD = [:source_id_str, :datasource_id]
FIELDS_TO_CREATE = [:name, :era_id, :owner_id, :current, :make_public]
FIELDS_TO_UPDATE = [:name, :era_id, :owner_id, :current, :make_public]
'''


Teaching group
'''
DB_CLASS = Teachinggroup
DB_KEY_FIELD = [:source_id, :datasource_id]
FIELDS_TO_CREATE = [:name, :era_id, :current]
FIELDS_TO_UPDATE = [:name, :era_id, :current]
'''


Tutor group
'''
DB_CLASS = Tutorgroup
DB_KEY_FIELD = [:source_id_str, :datasource_id]
FIELDS_TO_CREATE = [:name, :era_id, :staff_id, :house, :start_year, :current]
FIELDS_TO_UPDATE = [:name, :era_id, :staff_id, :house, :start_year, :current]
'''


Note that the teaching groups are still using source_id rather than source_id_str.  I probably want to change that.

Also, the era and era_id are being specified separately.  Only one is needed.  It seems I could start by having all groups specify the following:

'''
DB_KEY_FIELD = [:source_id_str, :datasource_id]
FIELDS_TO_CREATE = [:name, :era_id, :starts_on, :ends_on, :current]
FIELDS_TO_UPDATE = [:name, :era_id, :starts_on, :ends_on, :current]
'''

and remove the extras specified above.  Then deriving objects can specify their own DB_CLASS, and derive from the parent's other constants.

Custom group
'''
DB_CLASS = Taggroup
FIELDS_TO_CREATE = self.superclass::FIELDS_TO_CREATE + [:owner_id, :make_public]
FIELDS_TO_UPDATE = self.superclass::FIELDS_TO_CREATE + [:owner_id, :make_public]
'''


Need to check that the above actually works.  Checked it and it does.  You need to be slightly careful to make sure you access the intended one, but it does work.

Actually, I should clarify that.  If you're writing a instance method in your original class, which is to be called in an instance of the inheriting class, then you need to be explicit about wanting the actual class's constant.  Like this:

'''
class FirstClass
  DB_KEY_FIELD = [:source_id_str, :datasource_id]
  FIELDS_TO_CREATE = [:name, :era_id, :starts_on, :ends_on, :current]
  FIELDS_TO_UPDATE = [:name, :era_id, :starts_on, :ends_on, :current]

  def report
	puts "Have #{self.class::FIELDS_TO_CREATE.size} fields to create."
	self.class::FIELDS_TO_CREATE.each do |field|
	  puts field
	end
  end
end

class SecondClass < FirstClass
  DB_CLASS = :Taggroup
  FIELDS_TO_CREATE =
	self.superclass::FIELDS_TO_CREATE + [:owner_id, :make_public]
  FIELDS_TO_UPDATE =
	self.superclass::FIELDS_TO_CREATE + [:owner_id, :make_public]

  def report2
	puts "Have #{FIELDS_TO_CREATE.size} fields to create."
	FIELDS_TO_CREATE.each do |field|
	  puts field
	end
  end
end

FirstClass.new.report
SecondClass.new.report

SecondClass.new.report2
'''


Note that in report(), you need the "''self.class::''" bit, because otherwise the method would access FirstClass's constant.  Provided the method is defined in Second Class - as report2() is - you don't need to worry.  That's promising.

A thought - I'm fairly certain the MIS_Record code uses a different way of accessing the constant.  Yes, it uses:

''self.class.const_get(:FIELDS_TO_CREATE)''

That should work too.

I wonder - could I provide a helper function in the first class, which does the work of adding more.  Yes, I can.  Wowsers.
