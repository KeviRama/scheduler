Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2014-10-04T07:41:13+01:00

====== Saturday 04 Oct 2014 ======

About to do a spot of work on cover.  The current situation is that not all the cover makes it into my d/b, and I would like to generate e-mails for Ian when there are apparent issues with the cover.

One of the issues with cover not making it into the d/b is that I am only allowing cover for lessons, but it is also possible that people will be covering registration/assembly/chapel.  That's easy to fix.

The other problem is slightly more complex.  An error in the fundamental design of SB means that each event in its d/b can reference only one member of staff, one teaching group and one location.  Since we often have events involving more than one member of staff (e.g. sport or art) and even more than one group (assembly or chapel) it can't accommodate them properly.  As a workaround, the events are entered into SB's database umpteen times, once for each repeated item.

As part of my import process, I merge these separate events into one compound event, gathering together all the relevant resources and attaching them to just the one event.

When Ian then sets up cover for a member of staff on one of these events, I try to find it using SB's event id (timetable_ident), which is normally stored in my d/b as part of the event record.  However, where an event in my database is a compound event - built by merging several SB events - it is instead identified by a source_hash, which I generate from all the original timetable_idents.  I therefore can't find the relevant event in my d/b.  I can't reconstruct the source_hash, because that would require all the original timetable_idents, not just the one in the cover record.

I have therefore added a has to the code which does the merging of events.  Each time a collection of events are merged, an entry is created in the hash for each original event, indexed by the event's timetable_ident, which contains the new source_hash as its data.  It then becomes possible to tell:

a) Whether an event from SB has been merged
b) If so, what the source_hash of the merged event is

I am thus in a position to be able to identify the required event in my d/b, but...

...another problem arises.  It seems that ICF is in the habit of using people to cover events who are already commited to the same event.  Typically this happens when there are, say, ten people taking a year group for sport.  One of the ten is going to be absent, meaning a cover entry is required, and ICF simply chooses another from the ten (usually the senior - e.g. Andy Broadbent) to be the cover entry for the missing person.

As my code stands, it tries to create a second commitment to the single event for the covering person, which then fails the validation in the model - only one commitment per resource and event.

My first thought was to take the existing commitment (by the covering person) and link it to the commitment of the person requiring cover.  This would ensure that we continued to follow the rule of only one commitment per person/event pair.  I then realised that it would be possible for two people to be missing from the same event, with perhaps the same person being required to cover for both of them.  This then runs into an issue with the way commitments are linked for cover purposes.  At present the covering commitment points to the covered commitment, and the connection is specified as being one-to-one.

I considered reversing the connection (covered commitment points to covering commitment) and then making it many-to-one - one covering commitment could be connected to several covered commitments.  This would meet the requirement of the previous paragraph, and couldn't think of an instance where the many-to-one-ness would be required the other way.  We don't generally have the situation where several people need to cover for one absentee.  The nearest we get is when A is absent and B is due to cover, but then B is suddenly ill and C has to take over.  This can be accommodated with a chain of cover C => B => A, or simply by supplanting B in the cover records.

A further thought then occurred - I don't think this is the right way to do it at all.  The problem is that it is actually losing some information.  If I take an existing commitment by, say, AMB to an event and turn it into a cover commitment, then I lose the information that AMB was committed to that event in the first place.  This is philosophically wrong.

Looking at it practically, if one looks at AMB's timetable in Scheduler, he will appear to have just a cover commitment to the event.  There should be some visual indication that something extra is being required of him - that he is having to do someone else's job, or at least make arrangements for it to be done.  If a second absentee exists, then there should be a further indication.

Considering the question of calendar feeds - currently I just provide one feed per individual, but I have every intention of making this customisable in the near future.  I would like to have a separate feed for my cover commitments, so that I can get Google Calendar to display them in a different colour.  Thus I would have a normal feed from:

http://abingdon.scheduler.org.uk/ical/jhw?!cover

and another from:

http://abingdon.scheduler.org.uk/ical/jhw?cover

The first would provide everything but cover, and the second would provide the cover.  In the circumstance described above, I'd like the affected event to appear in //both// feeds.  It appears in the !cover feed because I am normally committed to it, then in the cover feed because I have extra duties.

Some colleagues prefer to take a static copy of their timetable, so they can edit it in GC.  They could then take a dynamic cover feed, and would similarly expect the event to appear in both.

We therefore need to preserve the information in the d/b, that the relevant person has two (or more) commitments to the event.  For this reason I think the correct solution is to change the constraint on commitments.  One person (or resource) can have more than one commitment to an event, provided they are distinct in their covering-ness.  That is, the group of event_id, element_id and covering_id must be unique.  (covering_id may be nil, but that's still just one possibility.)

I've done that change, and it effectively seems to work.  It's noticeable that when I view AMB's timetable the event which he is covering appears only once, although when I look at the list of resources, he appears twice.  Arguably he should appear as explicit cover for the person whom he is covering.

I no longer get any "Can't find the lesson" messages, which is odd because I would have thought I would get them for assemblies and registration.  Can I find an instance of one of these?  Yes - they do seem to be working now.  Perhaps I removed the check on lesson-ness earlier?  Yes - it appears I removed the check on eventcategory earlier - a couple of commits back.  Good.

What happens if I run the same load a second time?  Does downloading AMB's timetable still work?

There is a danger of confusion at the second run.  The original cover commitment won't be removed, because AMB is meant to be involved anyway, but then a new one might get added.  Take a careful look.  It seems OK, but further checking would be good.  I could do with code which displays exactly what is happening.

[ ] If a person is double committed to an event it should appear twice
[*] When looking at the resources for an event, the covering=>covered relationship should be clear.




Loader code is currently purging covers.  Do I want it to work that way?

Feeds and display should be driven primarily by //commitments//, not events.  One individual may now have more than one commitment to the same event, and we want to make sure that this is recorded.  I think I started on some code to implement this (perhaps stashed) and it now needs to be finished off.


Validation of commitments:

* Plain commitments are unique
* Cover commitments are unique for the person covered (can't cover same person twice)
* Cover commitments must refer to the same event as the original
