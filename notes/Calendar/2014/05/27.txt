Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2014-05-27T07:38:44+01:00

====== Tuesday 27 May 2014 ======

Time for a decision on how I name my models and structure their relationships.

In Markbook, I have a less flexible form of group membership, and two completely separate types of group - tutor groups and teaching groups.  The latter one is implemented as two separate models - mtgroup and utgroup - which I did in order to allow two different teachers to teach the same teaching group.  Their is one mtgroup record (which indicates the student membership and the group name) and then one or more utgroup records to link to the staff member and the teaching/prep slots.  This was all done before I had any idea of incorporating the timetable into my app, so I think it's now redundant.  Students and teachers are linked //directly// to these records, not via any kind of generalisation record.

Most importantly in Markbook I have the Resource model, which is the first incarnation of something which I intend to use again.  A Resource in Markbook is simply something I might want to see the details of.  I first implemented it to allow me to provide the fast search in the top right-hand corner of the screen.  Each Resource record points to exactly one Entity, and the Entity is one of the following types:

* Student
* Teacher
* Mtgroup
* Tutorgroup
* Location
* Supply
* Subject

Note that Subject here is slightly different from the others, in that it isn't something which could be scheduled.  I included a flag for this in the Resource record, but I don't think I ever actually used it.

Resource records are implemented using a neat feature of Rails called an Observer.  I have an EntityObserver model which spots the creation or deletion of any of the above resources and creates or deletes the corresponding Resource record.

In Xronos I picked up on this idea, but as I want to generalise groups, I took it a bit further (and renamed it).  Now groups consist not of specific entity types, but of Elements - which are much the same as Resources, but renamed.  Again, an EntityObserver model keeps track of the underlying entities, and creates and deletes Element records as required.  I never actually used the Elements for search purposes, but presumably one still could.

Now for Scheduler I intend to use the same technique again, and use observers twice.  Since I still need more than one kind of Group, I will have an underlying Group model which does all the hard work, but then a separate TutorGroup and TeachingGroup model to implement the specifics of these groups.  An observer will cause the Group to be created and deleted as required, and a mixed-in code module used in the TutorGroup and TeachingGroup models will provide transparent access to the membership.  This will then leave open the option for me to create other group types in the future - for instance general groups for users to fiddle with.

The second Observer will watch the following models (known as Entities):

* Pupil
* Staff
* TutorGroup
* TeachingGroup
* Location
* Supply

and create Element models to shadow each.  The elements will be what can be members of groups.  Note the change in name from Teacher to Staff, because it will need to encompass non-teaching staff as well as teachers.  I could arguably create a Person type, and use that to implement the common parts of Student and Staff, but I think that's getting a bit complicated.

The Group handling code will be imported direct from Xronos.  Membership records will point to Groups and Elements.

I've sketched out the model relationships - let's see whether we can load the staff records, along with corresponding Element records.  As far as I can see, they don't rely on anything else.

Generated my staff record with:

'''
rails g scaffold staff name initials surname title forename \
email source_id:integer active:boolean --skip-stylesheets
'''


Then before I run the migration I need to add the extra index.

'''
class CreateStaffs < ActiveRecord::Migration
  def change
    create_table :staffs do |t|
      t.string :name
      t.string :initials
      t.string :surname
      t.string :title
      t.string :forename
      t.string :email
      t.integer :source_id
      t.boolean :active

      t.timestamps
    end
    add_index :staffs, :source_id
  end
end
'''


Note that Rails has pluralized staff to staffs, which isn't quite right but I think we can live with it.

Interesting problem - Observers as we know them seem to have gone (or at least, been moved) in Rails 4.  All mention of them has gone from my agile book, and the initialisation code no longer works.  Reading a bit I find they are apparently deprecated and have been removed to a Gem.  There is also something new called a Concern, which might do what I want.  Of course, there are a zillion different gems calling themselves some kind of observer.  Which do I think is the right one?  Ah - apparently they're in a plugin.  Various alternative approaches are suggested too.

Apparently the vanilla gem is called rails-observers, and it does seem to be in the repository.  Take a look at the alternatives to see if they do it better.  I'm not sure that I understand what Concerns are, although it may be that they would provide the functionality which I want for my application.

Just established that Observers do still work, and I've got one running in my app.

Taken a quick look at Concerns.  Given that I want to add in some functionality code too, it might make sense to use them instead.  They can do the after_save processing, and provide some general methods which give access to the linked record.

For now I'm going to carry on using Observers for my element<=>entity relationship, but I might try Concerns when I come to do the types of Group.

Now see whether I can load my list of staff.  I think I need to create a model to do this kind of work.  How do I get Rails to recognize its existence?  Not sure, but discovered another way to do it.

If I put my script in the lib directory, I can invoke it with:

'''
rails runner lib/myscript.rb
'''

and it is run with the full Rails environment.  Or I can put it in a model in the app/models directory and invoke it with:

'''
rails runner 'Import.say_hello'
'''


or the like.  There's also a school of thought which would have me turn it into a Rake task.  Done a bit of reading, but found no conclusive arguments.  I think I'll just create a directory called lib/import and put everything there.

Got staff loading working satisfactorily.  I guess tutor groups are next, so I can lead up to loading the pupils.
