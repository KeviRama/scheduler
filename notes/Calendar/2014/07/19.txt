Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2014-07-19T07:27:53+01:00

====== Saturday 19 Jul 2014 ======

I'm going to go with the "everything starts on the 1st of September" option.  This will require the following changes:

[*] Utility to fix all my existing groups (tutor and teaching) and memberships
[*] Restore the previous behaviour of the members function, albeit with the change for an explicit date.
[ ] Check the working of the groups function - the inverse of the members function
[ ] Check and fix my loader code to ensure it always specifies a date when creating groups and when setting or querying membership (or indeed, removing members).

Interesting problem once you allow this behaviour.  It's easy to pick out who will be members of groups (the members method on the groups object) but the other way around is harder.  Having a groups method on an element, we want to pick out the groups for this academic year, even if they haven't started yet, but not all the groups from all the other academic years.

Various possible ways of doing it, more thought needed.

In the course of thinking, I've come up with another idea.

Currently I have tutorgroups and teachinggroups, each of which has a group model hiding behind it.  Various calls are passed through transparently to the hidden group model.  The problem is this adds an extra level of indirection, and possibly more database hits.

Currently, if I want to find all the groups which a pupil belongs to in a given era, I need to go from Pupil to Membership to Group to Tutor/Teaching group, because the era_id is held in the Tutor/Teaching group.  I can shorten this by moving the era id into the Group record (probably need to do that regardless), but perhaps I should turn round the way things work.  The database structures stay much the same, but instead of creating a Tutorgroup or Teachinggroup, you would create a group, specifying a type of Tutor or Teaching (or indeed, no type at all).  The record for the extra bits would then be created //behind// the group, and all manipulation would be done on the group.  Calls to Tutor/Teaching-specific stuff would be indirected through the Group model.  I could then have shim models in front, which allow you to call Tutorgroup.new still, but that would simply call Group.new(:type=tutor), or effectively that.

Each time a Group object got instantiated, it could gain some extra shim methods depending on its type.  Or they could be added dynamically by the use of method_missing.

What do I gain by doing it this way?  Well, it would avoid a certain amount of fiddling which occurs currently.

Currently I have:

Tutorgroup
Teachinggroup

which both mix in:

concerns/grouping

which links them to:

Group

For the new method, I'd want Tutorgroup and Teachinggroup still to exist, but merely as shims, not as database tables.  If you try to create a Tutorgroup or a Teachinggroup, it would instead create a Group, specifying the relevant type.  That would cause the underlying extra record to be created, but all manipulation would then be on the Group object.

The additional complication would then be if you try to find, say, all the tutorgroups in a house.  You'd have to know which database table to search, and it wouldn't be "groups".

It's an idea, and one to think about more, but for now I think that perhaps I will just move "era_id" and "current" into  the groups table.  It will have to be done in two steps in order to allow the data to be copied over.
