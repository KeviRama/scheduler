Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.4
Creation-Date: 2014-08-11T07:50:53+01:00

====== Monday 11 Aug 2014 ======

Today:

[*] Finish off group creation and editing
[ ] Do the same for events

Simple targets.  Achievable?

Just hit an interesting problem when I created an event on my calendar.  Although it had no commitments, the app went into a loop and then crashed.  It seemed to be something to do with the groups which I had at the time, because when I got rid of them it stopped happening.  Struggling now to reproduce the problem.

There must be some potential recursion still somewhere.  There seems to be some possibility of recursion in the element model - the events_on method.  Take a look.  Unfortunately the log file is large and there's stuff both before and after the problem.

Look for two requests with a lot of lines in between.

One request starts at line 43026 and seems to end at line 46943.  That's a lot.  Look at it in detail.

It was for events from the 10th to the 17th of August, with no other criteria specified.  That's the period containing my newly created event - id 247626.  I am logged in as my gmail user (user id 9).  I own element 10509, which is Vanessa, with id 2531.  Vanessa I'm pretty certain *was* a member of one of my then groups.  I then looked for all groups of which 10509 was a member in the specified interval.

Interesting - vim seems to do special processing on files with a .log extension.  It's much slower at loading them, and does fancy formatting.  It also won't let me amend them.  It moves the cursor to the end by default.

There's a definite loop there.  After a short preamble:

'''
Parameters: {"start"=>"2014-08-10", "end"=>"2014-08-17", "_"=>"1407745711478"}
User Load (0.1ms)  SELECT  `users`.* FROM `users`  WHERE `users`.`id` = 9 LIMIT 1
Ownership Load (0.1ms)  SELECT `ownerships`.* FROM `ownerships`  WHERE `ownerships`.`user_id` IN (9)
(0.1ms)  SELECT COUNT(*) FROM `ownerships`  WHERE `ownerships`.`user_id` = 9 AND `ownerships`.`equality` = 1
Ownership Load (0.1ms)  SELECT `ownerships`.* FROM `ownerships`  WHERE `ownerships`.`user_id` = 9 AND `ownerships`.`equality` = 1
Element Load (0.1ms)  SELECT  `elements`.* FROM `elements`  WHERE `elements`.`id` = 10509 LIMIT 1
(0.1ms)  SELECT COUNT(*) FROM `memberships`  WHERE `memberships`.`element_id` = 10509
Membership Load (0.1ms)  SELECT `memberships`.* FROM `memberships`  WHERE `memberships`.`element_id` = 10509 AND `memberships`.`inverse` = 0 AND (starts_on <= '2014-08-16') AND (ends_on IS NULL OR ends_on >= '2014-08-10')
'''


 the loop looks like this:

'''
Group Load (0.2ms)  SELECT  `groups`.* FROM `groups`  WHERE `groups`.`id` = 11134 LIMIT 1
Element Load (0.1ms)  SELECT  `elements`.* FROM `elements`  WHERE `elements`.`entity_id` = 11134 AND `elements`.`entity_type` = 'Group' LIMIT 1
(0.1ms)  SELECT COUNT(*) FROM `memberships`  WHERE `memberships`.`element_id` = 15758
Membership Load (0.1ms)  SELECT `memberships`.* FROM `memberships`  WHERE `memberships`.`element_id` = 15758 AND `memberships`.`inverse` = 0 AND (starts_on <= '2014-08-16') AND (ends_on IS NULL OR ends_on >= '2014-08-10')
'''


Let's compare that with the code, and work out where the loop is.

I don't understand why I'm seeing no event queries at all - instead it's focusing purely on groups and members.  I can't see how the path through the code is doing this.

I shouldn't have been so quick to delete those groups.  Try creating some again.

Looking at a working query, these group and element queries are a natural preamble to the first Event query.  Let's look at a working query now and compare.

'''
Parameters: {"start"=>"2014-08-10", "end"=>"2014-08-17", "_"=>"1407749324337"}
User Load (0.2ms)  SELECT  `users`.* FROM `users`  WHERE `users`.`id` = 9 LIMIT 1
Ownership Load (0.1ms)  SELECT `ownerships`.* FROM `ownerships`  WHERE `ownerships`.`user_id` IN (9)
(0.1ms)  SELECT COUNT(*) FROM `ownerships`  WHERE `ownerships`.`user_id` = 9 AND `ownerships`.`equality` = 1
Ownership Load (0.1ms)  SELECT `ownerships`.* FROM `ownerships`  WHERE `ownerships`.`user_id` = 9 AND `ownerships`.`equality` = 1
Element Load (0.1ms)  SELECT  `elements`.* FROM `elements`  WHERE `elements`.`id` = 10509 LIMIT 1
 (0.3ms)  SELECT COUNT(*) FROM `memberships`  WHERE `memberships`.`element_id` = 10509
Membership Load (0.3ms)  SELECT `memberships`.* FROM `memberships`  WHERE `memberships`.`element_id` = 10509 AND `memberships`.`inverse` = 0 AND (starts_on <= '2014-08-16') AND (ends_on IS NULL OR ends_on >= '2014-08-10')

'''
As before.

''Group Load (0.1ms)  SELECT  `groups`.* FROM `groups`  WHERE `groups`.`id` = 11143 LIMIT 1''
''Element Load (0.1ms)  SELECT  `elements`.* FROM `elements`  WHERE `elements`.`entity_id` = 11143 AND `elements`.`entity_type` = 'Group' LIMIT 1''
''(0.2ms)  SELECT COUNT(*) FROM `memberships`  WHERE `memberships`.`element_id` = 15767''
''Membership Load (0.2ms)  SELECT `memberships`.* FROM `memberships`  WHERE `memberships`.`element_id` = 15767 AND `memberships`.`inverse` = 0 AND (starts_on <= '2014-08-16') AND (ends_on IS NULL OR ends_on >= '2014-08-10')''
''Group Load (0.4ms)  SELECT  `groups`.* FROM `groups`  WHERE `groups`.`id` = 11142 LIMIT 1''
''Element Load (0.2ms)  SELECT  `elements`.* FROM `elements`  WHERE `elements`.`entity_id` = 11142 AND `elements`.`entity_type` = 'Group' LIMIT 1''
''(0.6ms)  SELECT COUNT(*) FROM `memberships`  WHERE `memberships`.`element_id` = 15766''
''SQL (0.1ms)  SELECT `events`.`id` AS t0_r0, `events`.`body` AS t0_r1,...''

I don't understand why we're getting these membership queries //before// fetching the elements own events.  Add some debug code.

Hah!  There are no event queries as a result of attempting to fetch direct events.  Why?  They don't even happen when I am succeeding in fetching and displaying a lot.  Clearly the code is not working the way I think it should.

Solved it!  At least the discrepancy - not the original problem.  The reason I'm not seeing a hit on the Events table is because Rails defers doing the actual query until you try to use the data.  As soon as I put in a check on the count retrieved, it started doing the actual query, but before that it was holding it as a potential query for the future.

On then to analysing what happened in my problem case.  Is it as simple as Vanessa being a member of a group which is also a member of itself?  Try it.  Yes - that seems to be the problem.  I get a stack too deep error.  I just need to implement recursion protection there too.

If a group is a member of itself, we should get events for that group, but once only.  Think I've implemented that now.  I've certainly stopped the application hanging in that particular circumstance.

Let's try popping it on to the live system.  Seems OK.

Now to set up editing resources into events.  The way I've set up editing members into groups is to have actions to create and delete memberships, even if they don't work quite that way.  It seems obvious to do much the same for commitments.

Basic adding and removing of resources is now working.  Two further things to pop in:

[*] Go straight from creation dialogue to editing dialogue
[*] Allow events to be deleted.

Interesting.  I just tried creating an all staff meeting on the 29th of August.  It shows up as being one of my events, but it doesn't show up as being an event which I'm attending.  Nor is Vanessa apparently there.  Why not?  Ah - I think I know.  This meeting is before the technical start of term, and therefore we are not yet members of the group.  Try it on the Monday and see if that makes a difference.  Yes, it's fine on Monday.  Now what is the correct solution to this problem?

Having thought about it a bit, I think it's just to say that I got the start date of the era wrong.  If things are happening to do with the new term, then the era has started.  I need to adjust the start date (to Thu 28/8, to allow for new staff INSET) and then make sure my script can update the start dates for the groups.

Odd - I just updated my script and ran it, and it seems to have added a lot of boys to teaching groups.  I'm not sure why it would have done that - yes I am.  Because the era date has changed it is checking the wrong start date, etc etc.

It won't actually have added them - it will should have just amended the start date of the membership - or it might have created duplicate memberships.  Yuk!  Need to check the logic carefully.  Changing the start date of an era is not as simple as I thought.

No - it hasn't created any duplicate memberships.  Because it was trying to create a membership before the start date of the group, that got adjusted to the start date of the group and then it was found to be already there.  No harm done.

If I want to change all my teaching and tutor groups to match the new era date then it calls for a bit of fiddling.  It might be easier simply to delete and re-create them.  Would that work?

[ ] Delete all teaching groups for the era
[ ] Delete all tutor groups for the era
[ ] In fact destroy all groups for the era
[ ] Re-load with the script

Try it on my test system.

This will take a while.  It will be interesting to see if it can re-attach the newly created groups to the existing events.  My first lesson of the term is event 212621 with S4 Ma-1c.  See if it comes back intact.  It seems to be the same event and has its teaching group back too - impressive!  The commitment by the teaching group even has the names_event flag set correctly.

I need to re-edit my manual events to put the groups back onto them, since they all got detached when they were deleted.

Seems tolerably successful.  Need to test again with a fresh copy of the school d/b and data.

Had to rename the groups for a whole house because I realised that "School House" could equally be a location.  Now called "School House pupils".

Odd - I ran my amended script and the only new group which it created was "Lower School pupils".  Why?  Because I only made the change in the Lower School section.  Need to be more careful.

Let's try and achieve those two objectives above before I commit the code and test the upgrade process again with a fresh copy of the live data.
